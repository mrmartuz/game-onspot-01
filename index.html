<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EXPOGA</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        #status-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background-color: gray;
            color: white;
            text-align: center;
            line-height: 50px;
            z-index: 10;
            font-size: 16px;
        }
        #date-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background-color: gray;
            color: white;
            text-align: center;
            line-height: 30px;
            z-index: 10;
            font-size: 16px;
        }
        #game-canvas {
            position: absolute;
            top: 50px;
            left: 0;
            width: 100%;
            height: calc(100vh - 80px);
            background-color: black;
        }
        button {
            position: absolute;
            z-index: 10;
            width: 50px;
            height: 50px;
            font-size: 20px;
            border: 1px solid white;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 50%;
            touch-action: manipulation;
        }
        #btn-n { top: 60px; left: calc(50% - 25px); }
        #btn-ne { top: 60px; right: 10px; }
        #btn-e { top: calc(50% + 10px); right: 10px; } /* Adjusted for bars */
        #btn-se { bottom: 40px; right: 10px; }
        #btn-s { bottom: 40px; left: calc(50% - 25px); }
        #btn-sw { bottom: 40px; left: 10px; }
        #btn-w { top: calc(50% + 10px); left: 10px; }
        #btn-nw { top: 60px; left: 10px; }
    </style>
</head>
<body>
    <div id="status-bar">Loading...</div>
    <canvas id="game-canvas"></canvas>
    <div id="date-bar">Loading...</div>
    <button id="btn-n">N</button>
    <button id="btn-ne">NE</button>
    <button id="btn-e">E</button>
    <button id="btn-se">SE</button>
    <button id="btn-s">S</button>
    <button id="btn-sw">SW</button>
    <button id="btn-w">W</button>
    <button id="btn-nw">NW</button>
    <script>
        // Game variables
        let px = 0, py = 0;
        let prevx = 0, prevy = 0;
        let visited = new Set(['0,0']);
        let changed = []; // {x, y, type}
        let killed = new Set();
        let seed = 42;
        let viewWidth = 21, viewHeight = 21;
        let viewDist = 5;
        let cooldown = false;
        let health = 100;
        let gold = 100;
        let food = 100;
        let water = 100;
        let tents = 2;
        let building_mats = 10;
        let wood = 10;
        let group = [
            {role: 'explorer', bonus: {discovery: 0.2}},
            {role: 'carrier', bonus: {carry: 0.2}}
        ];
        let discoverPoints = 0;
        let killPoints = 0;
        let moves = 0;

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let tileSize = 30;
        let offsetX = 0, offsetY = 0;

        // Resize handler
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 80;
            viewWidth = Math.floor(canvas.width / tileSize);
            if (viewWidth % 2 === 0) viewWidth--;
            viewHeight = Math.floor(canvas.height / tileSize);
            if (viewHeight % 2 === 0) viewHeight--;
            offsetX = (canvas.width - viewWidth * tileSize) / 2;
            offsetY = (canvas.height - viewHeight * tileSize) / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        // Hash function for procedural generation
        function hash(x, y, s) {
            let n = x * 12345 + y * 6789 + s * 98765 + seed;
            n = Math.sin(n) * 43758.5453;
            return n - Math.floor(n);
        }

        // Get tile data
        function getTile(x, y) {
            const key = `${x},${y}`;
            let change = changed.find(t => t.x === x && t.y === y);
            let location = change ? change.type : 'none';
            if (location === 'none') {
                let h1 = hash(x, y, 1);
                if (h1 < 0.05) {
                    const locations = ['waterfalls', 'canyon', 'geyser', 'peaks', 'monster caves', 'cave', 'ruin', 'camp', 'farm', 'outpost', 'hamlet', 'village', 'city'];
                    location = locations[Math.floor(hash(x, y, 2) * locations.length)];
                }
            }
            let entity = 'none';
            let h3 = hash(x, y, 3);
            if (h3 < 0.05) {
                const entities = ['monster', 'beast', 'animal', 'npc', 'group', 'army', 'trader', 'caravan'];
                entity = entities[Math.floor(hash(x, y, 4) * entities.length)];
            }
            if (killed.has(key)) entity = 'none';
            let height = Math.floor(hash(x, y, 5) * 11);
            let flora = Math.floor(hash(x, y, 6) * 11);
            let inclination = 0;
            [[0,-1],[0,1],[-1,0],[1,0]].forEach(d => {
                let nh = Math.floor(hash(x + d[0], y + d[1], 5) * 11);
                inclination = Math.max(inclination, Math.abs(height - nh));
            });
            let terrain = height < 4 ? 'sand' : height < 8 ? 'dirt' : 'rock';
            return {height, inclination, terrain, flora, location, entity};
        }

        // Emojis for rendering
        function getEmojiForLocation(type) {
            const map = {
                'waterfalls': '💦', 'canyon': '🕳️', 'geyser': '🌋', 'peaks': '🏔️',
                'monster caves': '🦇', 'cave': '🕸️', 'ruin': '🏚️', 'camp': '⛺',
                'farm': '🌾', 'outpost': '🏕️', 'hamlet': '🏘️', 'village': '🏡', 'city': '🏙️'
            };
            return map[type] || '❓';
        }

        function getEmojiForEntity(type) {
            const map = {
                'monster': '👹', 'beast': '🦁', 'animal': '🐕', 'npc': '🧑',
                'group': '👥', 'army': '⚔️', 'trader': '💼', 'caravan': '🐪'
            };
            return map[type] || '❓';
        }

        // Draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (let vx = 0; vx < viewWidth; vx++) {
                for (let vy = 0; vy < viewHeight; vy++) {
                    let tx = px - Math.floor(viewWidth / 2) + vx;
                    let ty = py - Math.floor(viewHeight / 2) + vy;
                    let tile = getTile(tx, ty);
                    let drawX = offsetX + vx * tileSize;
                    let drawY = offsetY + vy * tileSize;
                    let key = `${tx},${ty}`;
                    if (!visited.has(key)) {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(drawX, drawY, tileSize, tileSize);
                        continue;
                    }
                    ctx.fillStyle = tile.terrain === 'sand' ? 'yellow' : tile.terrain === 'dirt' ? 'brown' : 'gray';
                    ctx.fillRect(drawX, drawY, tileSize, tileSize);
                    if (tile.flora > 0) {
                        ctx.fillStyle = `rgba(0,255,0,${tile.flora / 20})`;
                        ctx.fillRect(drawX, drawY, tileSize, tileSize);
                    }
                    if (tile.flora > 6) {
                        ctx.font = '20px serif';
                        ctx.fillText('🌲', drawX + tileSize / 2, drawY + tileSize / 2);
                    }
                    ctx.fillStyle = `rgba(0,0,0,${tile.height / 30})`;
                    ctx.fillRect(drawX, drawY, tileSize, tileSize);
                    if (tile.location !== 'none') {
                        ctx.font = '20px serif';
                        ctx.fillText(getEmojiForLocation(tile.location), drawX + tileSize / 2, drawY + tileSize / 2);
                    }
                    if (tile.entity !== 'none') {
                        ctx.font = '20px serif';
                        ctx.fillText(getEmojiForEntity(tile.entity), drawX + tileSize / 2, drawY + tileSize / 2);
                    }
                }
            }
            // Draw player
            let playerX = offsetX + Math.floor(viewWidth / 2) * tileSize + tileSize / 2;
            let playerY = offsetY + Math.floor(viewHeight / 2) * tileSize + tileSize / 2;
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(playerX, playerY, tileSize / 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Update status bar
        function updateStatus() {
            document.getElementById('status-bar').innerText = `Gold: ${Math.floor(gold)} Food: ${Math.floor(food)} Water: ${Math.floor(water)} Health: ${Math.floor(health)} Group: ${group.length}`;
        }

        // Get group bonus
        function getGroupBonus(type) {
            return group.reduce((total, g) => total + (g.bonus[type] || 0), 0);
        }

        // Day consumption
        function dayConsumption() {
            food -= group.length * (1 - getGroupBonus('food'));
            water -= group.length;
            gold -= group.length * 0.5;
            if (Math.random() < 0.05) tents = Math.max(0, tents - 1);
        }

        // Update resources on move
        function updateResources(tile) {
            let foodConsume = 0.1 * group.length * (1 - getGroupBonus('food'));
            food -= foodConsume;
            water -= 0.1 * group.length;
            food += tile.flora * 0.1 * (1 + getGroupBonus('plant'));
            if (Math.random() < 0.05 * (1 + getGroupBonus('resource'))) wood += 1;
            moves++;
            if (moves % 10 === 0) dayConsumption();
        }

        // Handle combat
        function handleCombat(ex, ey, isOnTile = false) {
            let input = prompt(`Hostile at (${ex},${ey})! 1: Attack, 2: Flee`);
            if (input === '2') {
                if (isOnTile) {
                    px = prevx;
                    py = prevy;
                    alert('Fled back.');
                } else {
                    alert('Fled, staying put.');
                }
                return false;
            }
            let combatBonus = getGroupBonus('combat');
            let success = Math.random() < 0.5 + combatBonus;
            if (success) {
                alert('Victory!');
                killed.add(`${ex},${ey}`);
                killPoints += 5;
                return true;
            } else {
                alert('Defeat! Took damage.');
                health -= isOnTile ? 20 : 10;
                return false;
            }
        }

        // Check adjacent monsters
        function checkAdjacentMonsters() {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let tile = getTile(px + dx, py + dy);
                    if (tile.entity === 'monster' || tile.entity === 'beast') {
                        handleCombat(px + dx, py + dy);
                    }
                }
            }
        }

        // Check tile interaction
        function checkTileInteraction(tile) {
            if (['monster', 'beast'].includes(tile.entity)) {
                handleCombat(px, py, true);
                return;
            }
            if (tile.location !== 'none' || tile.entity !== 'none') {
                if (['waterfalls', 'canyon', 'geyser', 'peaks', 'monster caves', 'cave', 'ruin'].includes(tile.location)) {
                    discoverPoints += 10;
                    alert(`Discovered ${tile.location}!`);
                }
                let options = ['1: Leave'];
                if (['camp', 'outpost'].includes(tile.location)) options.push('2: Rest');
                if (['outpost', 'hamlet', 'village', 'city'].includes(tile.location) || ['trader', 'caravan'].includes(tile.entity)) {
                    options.push('3: Trade');
                    options.push('4: Hire');
                }
                if (tile.location === 'city') options.push('5: Sell discoveries');
                if (tile.location === 'village') options.push('6: Sell hunts');
                let msg = `At ${tile.location} ${tile.entity}\n${options.join('\n')}`;
                let choice = prompt(msg);
                handleChoice(choice, tile);
            }
        }

        // Handle interaction choice
        function handleChoice(choice, tile) {
            if (choice === '2') { // Rest
                health = Math.min(100, health + 10 * (1 + getGroupBonus('health')));
                food -= group.length * 0.5;
                water -= group.length * 0.5;
                alert('Rested.');
            } else if (choice === '3') { // Trade
                let t = prompt('1: Buy food (10g for 10), 2: Buy water (10g for 10), 3: Sell wood (5 for 10g)');
                if (t === '1' && gold >= 10) { food += 10; gold -= 10; }
                if (t === '2' && gold >= 10) { water += 10; gold -= 10; }
                if (t === '3' && wood >= 5) { wood -= 5; gold += 10; }
            } else if (choice === '4') { // Hire
                const roles = ['native-guide', 'cook', 'guard', 'geologist', 'biologist', 'translator', 'carrier', 'medic', 'navigator'];
                let hires = [];
                for (let i = 0; i < 3; i++) {
                    let r = roles[Math.floor(Math.random() * roles.length)];
                    let cost = 50 + Math.floor(Math.random() * 50);
                    hires.push(`${i+1}: ${r} for ${cost}g`);
                }
                let c = prompt(hires.join('\n'));
                if (c && ['1','2','3'].includes(c)) {
                    let idx = parseInt(c) - 1;
                    let [ , role, , costStr ] = hires[idx].split(' ');
                    let cost = parseInt(costStr);
                    if (gold >= cost) {
                        group.push({role, bonus: getBonusForRole(role)});
                        gold -= cost;
                        alert(`Hired ${role}.`);
                    } else alert('Not enough gold.');
                }
            } else if (choice === '5') { // Sell discoveries
                gold += discoverPoints;
                discoverPoints = 0;
                alert('Sold discoveries.');
            } else if (choice === '6') { // Sell hunts
                gold += killPoints;
                killPoints = 0;
                alert('Sold hunts.');
            }
        }

        function getBonusForRole(role) {
            const bonuses = {
                'native-guide': {navigation: 0.2},
                'explorer': {discovery: 0.2},
                'cook': {food: 0.2},
                'guard': {combat: 0.2},
                'geologist': {resource: 0.2},
                'biologist': {plant: 0.2},
                'translator': {interact: 0.2},
                'carrier': {carry: 0.2},
                'medic': {health: 0.2},
                'navigator': {view: 1}
            };
            return bonuses[role] || {};
        }

        // Reveal tiles within view distance
        function revealAround() {
            let currentViewDist = viewDist + Math.floor(getGroupBonus('view'));
            for (let ddx = -currentViewDist; ddx <= currentViewDist; ddx++) {
                for (let ddy = -currentViewDist; ddy <= currentViewDist; ddy++) {
                    if (Math.sqrt(ddx * ddx + ddy * ddy) <= currentViewDist) {
                        visited.add(`${px + ddx},${py + ddy}`);
                    }
                }
            }
        }

        // Movement function
        function move(dx, dy) {
            if (cooldown) return;
            let tx = px + dx;
            let ty = py + dy;
            let tile = getTile(tx, ty);
            let navBonus = getGroupBonus('navigation');
            let cooldownMs = (500 + tile.inclination * 100 + tile.flora * 50) * (1 - navBonus);
            cooldown = true;
            setTimeout(() => {
                prevx = px;
                prevy = py;
                px = tx;
                py = ty;
                visited.add(`${px},${py}`);
                revealAround();
                updateResources(tile);
                checkAdjacentMonsters();
                checkTileInteraction(tile);
                if (health <= 0 || gold < -50) {
                    alert('Game Over!');
                    // Reset game (simple)
                    location.reload();
                }
                cooldown = false;
            }, cooldownMs);
        }

        // Button listeners (use click for tap)
        const directions = [
            {id: 'btn-n', dx: 0, dy: -1},
            {id: 'btn-ne', dx: 1, dy: -1},
            {id: 'btn-e', dx: 1, dy: 0},
            {id: 'btn-se', dx: 1, dy: 1},
            {id: 'btn-s', dx: 0, dy: 1},
            {id: 'btn-sw', dx: -1, dy: 1},
            {id: 'btn-w', dx: -1, dy: 0},
            {id: 'btn-nw', dx: -1, dy: -1}
        ];
        directions.forEach(dir => {
            document.getElementById(dir.id).addEventListener('click', () => move(dir.dx, dir.dy));
        });

        // Show menu function
        function showMenu() {
            let inv = `Health: ${health} Gold: ${gold} Food: ${food.toFixed(1)} Water: ${water.toFixed(1)} Tents: ${tents} Mats: ${building_mats} Wood: ${wood}`;
            let grp = group.map(g => g.role).join(', ');
            let msg = `${inv}\nGroup: ${grp}\n1: Close, 2: Build camp (5 mats, 5 wood), 3: Build outpost (10 mats, 10 wood)`;
            let choice = prompt(msg);
            if (choice === '2' || choice === '3') {
                let costMats = choice === '2' ? 5 : 10;
                let costWood = choice === '2' ? 5 : 10;
                let type = choice === '2' ? 'camp' : 'outpost';
                if (building_mats >= costMats && wood >= costWood) {
                    let dirStr = prompt('Direction: N NE E SE S SW W NW');
                    const dmap = {
                        'N': {dx:0,dy:-1}, 'NE':{dx:1,dy:-1}, 'E':{dx:1,dy:0}, 'SE':{dx:1,dy:1},
                        'S':{dx:0,dy:1}, 'SW':{dx:-1,dy:1}, 'W':{dx:-1,dy:0}, 'NW':{dx:-1,dy:-1}
                    };
                    let d = dmap[dirStr ? dirStr.toUpperCase() : ''];
                    if (d) {
                        let bx = px + d.dx;
                        let by = py + d.dy;
                        let btile = getTile(bx, by);
                        if (btile.location === 'none' && btile.entity === 'none') {
                            changed.push({x: bx, y: by, type});
                            building_mats -= costMats;
                            wood -= costWood;
                            alert(`Built ${type}.`);
                        } else alert('Cannot build there.');
                    } else alert('Invalid direction.');
                } else alert('Not enough materials.');
            }
        }

        // Tap on player for menu
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let touchX = e.touches[0].clientX - rect.left;
            let touchY = e.touches[0].clientY - rect.top;
            let vx = Math.floor((touchX - offsetX) / tileSize);
            let vy = Math.floor((touchY - offsetY) / tileSize);
            let centerV = Math.floor(viewWidth / 2);
            if (vx === centerV && vy === centerV) {
                showMenu();
            }
        });

        // Tap on status bar for menu
        document.getElementById('status-bar').addEventListener('touchstart', (e) => {
            e.preventDefault();
            showMenu();
        });

        // Update date bar
        setInterval(() => {
            document.getElementById('date-bar').innerText = new Date().toLocaleString();
        }, 1000);

        // Game loop
        function loop() {
            draw();
            updateStatus();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>